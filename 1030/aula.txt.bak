Aula 19 e 20 -> Teste de Integração -> Não vimos
	São chamadas de função
	Teste mockado para ver se funciona primeiro
	Depois tiramos mock e testamos
	
	Ex: Mockito -> Criamos classes e métodos mockadas
		Nisso, quando chamamos no nosso programa, ele vai pegar do mock
		Isso facilita para não ficar alterando nosso código para testar com mock
		
	BDD -> Forma de desenvolvimento
	

Aula 21
Teste Unitário

	TDD -> Test Driven Development
		Forma de desenvolver software que está sendo empregado nas principais indústrias de software
		
	Pair Programming -> 2 caras fazendo o mesmo código juntos
	
	TDD
		Primeiro fazemos os testes, depois o código
		Desenvolvimento orientado a testes
		
		Eclipse + JUnit
	
		Teste é parte da programação
		
		Nasce antes do programa
		
		A ideia é que no final, quando terminar de codar, não vai ser necessário testar mais nada
		
		Exemplo:
			Classe Criptografadora, com método criptografa que recebe uma letra char, e retorna o valor criptografado em int
			
			Criar projeto java, usar JUnit 4
			-> Não criamos a classe ainda, vamos criar a JUNIT Test Case

public class TestadoraCriptografia {

	//Teste de conversão do A em 19
	@Test
	public void testeConversaoA() {
		Criptografadora cripta = new Criptografadora();
		int valorRetorno = cripta.criptografar('A');
		assertEquals(valorRetorno, 19);
	}

}

			Primeiro garantimos que ainda não existia, então deve dar erro
			Depois criamos a classe de forma bem simples, KISS, Keep It Simple Stupid

public class Criptografadora {

	public int criptografar(char letra) {
		return 19;
	}
	
}

			Não saímos fazendo tudo junto, só para testar o primeiro caso por enquanto
			
			Depois implementamos a lógica para esse teste e testamos
			
			Criamos segundo teste, rodamos, garantimos que deu erro
			
			Implementamos segunda lógica, testamos para ver se deu certo
			
			...
			
		Pode parecer que você está gastando muito mais tempo, mas na verdade é bem pouca a diferença
		
		O que fizemos é:
			Teste de Condição de Equivalência
				Baseado na Teoria de Conjuntos
			
				A partir de um conjunto de interesse, testamos equivalência para cada valor
				
				Então fora os testes esperados, temos um teste para verificar a exceção
		
Aula 22
Apresenta como podemos criar testes unitários
	Precisamos sempre pensar em isolar programas
	Mockamos códigos externos para não influenciar
	
	Métodos de definição de casos de teste
	
	- Iniciação de variáveis
		Uma das maiores causas de falhas intermitentes em software é a falta de inicialização de variáveis
			variáveis que ficam com lixo de execuções anteriores etc
		
		* Listamos as variáveis
		* Checamos o primeiro local em que é usado para decisão ou cálculo
		* Verificamos se foi inicializado
	- Caminhos mínimos
		Cobre o máximo possível do programa com o mínimo de esforço
		
		Então é um teste mínimo
		
		Também chamado de complexidade ciclomática, ou de McCabe
		
		Usa teoria dos grafos
			Analisa o programa em grafo de caminhos
		
		Cada nó de decisão abre um novo caminho
		
		Então ele tenta garantir que passou por cada linha do código
		Garante que passou 1 vez em cada linha do código
		
		Podemos desenhas o caminho do código por linha
		Ou
		Regra de McCabe 
			NroTestes = NroDecisões + 1
			
		Para testar, criamos várias combinações de inputs, de forma que a execução passe pelos caminhos desejados, definimos o output esperado
		Podemos ir fazendo testes de mesa para descobrir
	- Teste de Enlace
		Aplicáveis em testes Funcionais de nível Unitário
		Requer conhecimento da lógica interna, ou seja, caixa branca
		
		A ideia é avaliar trechos de código em loop
		Complementam o Teste de Complexidade Ciclomática
		
		Avalia três condições mínimas de um mesmo ponto de decisão:
			* Não entrar no loop
			* Ficar no loop ao menos uma vez
			* Realizar ao menos um retorno no ciclo, com reexecução do mesmo trecho de código
		
		Para planejar, começamos sempre pelo loop mais interno e vamos indo para fora
		
		Quando o loop executa uma condição antes da sentença, teremos 3 testes mínimos, caso contrário 2. Ex: While e For. Do While são 2 testes
		
		É só somar 3 para cada loop com condição inicial, 2 para cada um com condição no final
		
		Definimos para cada teste:
			Identificador
			Objetivo
			Preparação
			Entrada
			Saída
		Obs: O teste vem antes do código
	- Teste de Limites
		Assim como o anterior, aplicável em funcionais de nível unitário, caixa branca
		Tenta avaliar valores que influenciam decisões, sendo semelhante aos testes mínimos de Mc Cabe, porém explora melhor
		as decisões.
		Incrementa testes mínimos e de enlace, já que executa eles mais de uma vez
		
		Ex: O teste de caminho mínimo verificaria um 10 < x < 100 duas vezes, uma vez entrando na condição, outra saindo
			O teste de limite verificaria 4 vezes, estando fora pelo limite inferior, superior, e dentro pelos limites superior e inferior
		
		A ideia é focar as entradas próximas dos limites:
		1. Fora do limite inferior
		2. Dentro do limite inferior
		3. Fora do limite superior
		4. Dentro do limite superior
		
		Por que testar duas vezes quando está dentro do limite? Porque um <= ou < faz diferença, se fizerem duas condições separadas também
	- Teste de Partição / Condição de Equivalência
		Assim como o anterior, aplicável em funcionais de nível unitário, caixa branca
		
		Avalia grupos de valores que implicam nas decisões, parecido com limites, mas pode trabalhar com valores não numéricos
		
		Incrementa os testes mínimos, enlace e de limites, já que executa eles mais de uma vez
		
		Para isso observamos os conjuntos de dados que levam aos mesmos resultados, válidos e inválidos
		Nele criamos um teste para cada valor do conjunto válido, e um único para o conjunto inválido
		
		