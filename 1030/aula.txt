Aula 19 e 20 -> Teste de Integração -> Não vimos
	São chamadas de função
	Teste mockado para ver se funciona primeiro
	Depois tiramos mock e testamos
	
	Ex: Mockito -> Criamos classes e métodos mockadas
		Nisso, quando chamamos no nosso programa, ele vai pegar do mock
		Isso facilita para não ficar alterando nosso código para testar com mock
		
	BDD -> Forma de desenvolvimento
	

Aula 21
Teste Unitário

	TDD -> Test Driven Development
		Forma de desenvolver software que está sendo empregado nas principais indústrias de software
		
	Pair Programming -> 2 caras fazendo o mesmo código juntos
	
	TDD
		Primeiro fazemos os testes, depois o código
		Desenvolvimento orientado a testes
		
		Eclipse + JUnit
	
		Teste é parte da programação
		
		Nasce antes do programa
		
		A ideia é que no final, quando terminar de codar, não vai ser necessário testar mais nada
		
		Exemplo:
			Classe Criptografadora, com método criptografa que recebe uma letra char, e retorna o valor criptografado em int
			
			Criar projeto java, usar JUnit 4
			-> Não criamos a classe ainda, vamos criar a JUNIT Test Case

public class TestadoraCriptografia {

	//Teste de conversão do A em 19
	@Test
	public void testeConversaoA() {
		Criptografadora cripta = new Criptografadora();
		int valorRetorno = cripta.criptografar('A');
		assertEquals(valorRetorno, 19);
	}

}

			Primeiro garantimos que ainda não existia, então deve dar erro
			Depois criamos a classe de forma bem simples, KISS, Keep It Simple Stupid

public class Criptografadora {

	public int criptografar(char letra) {
		return 19;
	}
	
}

			Não saímos fazendo tudo junto, só para testar o primeiro caso por enquanto
			
			Depois implementamos a lógica para esse teste e testamos
			
			Criamos segundo teste, rodamos, garantimos que deu erro
			
			Implementamos segunda lógica, testamos para ver se deu certo
			
			...
			
		Pode parecer que você está gastando muito mais tempo, mas na verdade é bem pouca a diferença
		
		O que fizemos é:
			Teste de Condição de Equivalência
				Baseado na Teoria de Conjuntos
			
				A partir de um conjunto de interesse, testamos equivalência para cada valor
				
				Então fora os testes esperados, temos um teste para verificar a exceção
		
Aula 22
Apresenta como podemos criar testes unitários
	Precisamos sempre pensar em isolar programas
	Mockamos códigos externos para não influenciar
	
	Métodos de definição de casos de teste
	
	- Iniciação de variáveis
		Uma das maiores causas de falhas intermitentes em software é a falta de inicialização de variáveis
			variáveis que ficam com lixo de execuções anteriores etc
		
		* Listamos as variáveis
		* Checamos o primeiro local em que é usado para decisão ou cálculo
		* Verificamos se foi inicializado
	- Caminhos mínimos
		Cobre o máximo possível do programa com o mínimo de esforço
		
		Então é um teste mínimo
		
		Também chamado de complexidade ciclomática, ou de McCabe
		
		Usa teoria dos grafos
			Analisa o programa em grafo de caminhos
		
		Cada nó de decisão abre um novo caminho
		
		Então ele tenta garantir que passou por cada linha do código
		Garante que passou 1 vez em cada linha do código
		
		Podemos desenhas o caminho do código por linha
		Ou
		Regra de McCabe 
			NroTestes = NroDecisões + 1
			
		Para testar, criamos várias combinações de inputs, de forma que a execução passe pelos caminhos desejados, definimos o output esperado
		Podemos ir fazendo testes de mesa para descobrir
	- 